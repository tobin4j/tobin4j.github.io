<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scala学习笔记 | 李白光的个人博客🌠</title>
<meta name="description" content="热爱可抵岁月漫长" />
<link rel="shortcut icon" href="https://tobin4j.github.io/favicon.ico?v=1590823003562">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://tobin4j.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-SZ9Z4FDNQP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SZ9Z4FDNQP');
</script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://tobin4j.github.io">
  <img class="avatar" src="https://tobin4j.github.io/images/avatar.png?v=1590823003562" alt="">
  </a>
  <h1 class="site-title">
    李白光的个人博客🌠
  </h1>
  <p class="site-description">
    热爱可抵岁月漫长
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Scala学习笔记
            </h2>
            <div class="post-info">
              <span>
                2019-12-28
              </span>
              <span>
                11 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>主要记录学习Scala基础语法，因为我主语言是Java，笔记主要比较了和Java的异同。</p>
<!-- more -->
<blockquote>
<p>语言特点:编译后同样是.class文件允许在Jvm的语言，和Java包无缝互调</p>
</blockquote>
<h3 id="变量类型">变量类型</h3>
<ol>
<li>普通变量</li>
</ol>
<pre><code class="language-java">var myVar : String = &quot;Foo&quot;
</code></pre>
<p>代表声明了一个变量叫 myVar ，类型是 String , 值是 “foo”<br>
如果不声明冒号后面的String，则会默认推断值的类型<br>
2. 常量</p>
<pre><code class="language-java">val myVar : String = &quot;Foo&quot;
</code></pre>
<p>不同的是改声明的变量后续不能被再次赋值<br>
3. 多个变量声明</p>
<pre><code class="language-java">var a,b = 1 //两个变量都声明为1
</code></pre>
<ol start="4">
<li>方法返回值是元祖</li>
</ol>
<pre><code class="language-java">var tmp = (1,2)
</code></pre>
<blockquote>
<p>可以直接接受然后推测类型</p>
</blockquote>
<h3 id="访问修饰符">访问修饰符</h3>
<p>不声明默认是public，priate和protected比Java更严格</p>
<pre><code class="language-java">//作用域保护
private[x] 
//x是包名,代表其声明的类或对象对x包中的类开放
protected[x]
</code></pre>
<h3 id="运算符">运算符</h3>
<p>scala没有++,--运算符</p>
<h3 id="循环">循环</h3>
<ul>
<li>while 和 do...while和Java一样</li>
<li>没有break和continue(有包可以解决)</li>
</ul>
<pre><code class="language-java">for (a &lt;- 1 to 10){
    //遍历1到10（包含）
}

for (a &lt;- 1 until 10){
    //遍历1到10（不包含）
}

for (a &lt;- 1 to 10;b &lt;- 1 to 15 ){
    //遍历a和b所有存在的组合(相当去嵌套循环)
}

for (a &lt;- list){
    //遍历集合对象
}

for (a &lt;- 1 to 10
    if a%2==0){
    //for循环机中过滤
}

var sl= for (a &lt;- 1 until 10){
    //将遍历结果a汇总后赋值给sl
      }yield a
</code></pre>
<h3 id="方法与函数">方法与函数</h3>
<ol>
<li>方法定义</li>
</ol>
<pre><code class="language-java">//定义一个方法叫add,接受两个Int类型的参数,返回值是Int
//只有一行大括号和return可以省略
//返回值可以是Unit 相当Java的void
//可以指定默认值
//可以嵌套
def add(x:Int=5,y:Int) : Int = {
    return x+y
}
</code></pre>
<ol start="2">
<li>函数定义</li>
</ol>
<pre><code class="language-java">val add = (x:Int,y:Int) =&gt; x+y
//可以根据参数名指定调用顺序
print(add(y=1,x=2))
//定义可变长参数
def add(args:Int*) ={
    
}
</code></pre>
<ol start="3">
<li>其他</li>
</ol>
<p>https://www.runoob.com/scala/scala-functions.html</p>
<h3 id="闭包">闭包</h3>
<p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</p>
<pre><code class="language-java">var a = 2
var fun = (b:Int) =&gt; a+b
</code></pre>
<h3 id="数组">数组</h3>
<ol>
<li>数组定义</li>
</ol>
<pre><code class="language-java">var arr1 : Array[String] = new Array[String](3)
//下标索引
arr1(0)=&quot;str0&quot;
arr1(1)=&quot;str1&quot;
arr1(2)=&quot;str2&quot;
//或
val arr2 = Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)
//遍历
for (str &lt;- arr2){
  println(str)
}
</code></pre>
<ol start="2">
<li>二维数组</li>
</ol>
<pre><code class="language-java">//定义,赋值,遍历
import Array._
var mat = ofDim[Int](3,3)
for (a &lt;- 0 to 2;b&lt;- 0 until 3){
  mat(a)(b)=666
}
for (a &lt;- 0 to 2){
  for (b&lt;- 0 until 3){
    print(mat(a)(b))
    print(&quot; &quot;)
  }
  println()
}
</code></pre>
<ol start="3">
<li>合并数组</li>
</ol>
<pre><code class="language-java">var myList1 = Array(1.9, 2.9, 3.4, 3.5)
var myList2 = Array(8.9, 7.9, 0.4, 1.5)

var myList3 =  concat( myList1, myList2)

// 输出所有数组元素
for ( x &lt;- myList3 ) {
  println( x )
}
</code></pre>
<ol start="4">
<li>创建区间数组</li>
</ol>
<pre><code class="language-java">//range函数最后一个形参是步长,默认1
var myList1 = range(10, 20, 2)
var myList2 = range(10,20)

// 输出所有数组元素
for ( x &lt;- myList1 ) {
    print( &quot; &quot; + x )
}
println()
for ( x &lt;- myList2 ) {
    print( &quot; &quot; + x )
}
</code></pre>
<ol start="5">
<li><a href="https://www.runoob.com/scala/scala-arrays.html">常用方法</a></li>
</ol>
<h3 id="集合">集合</h3>
<p><a href="https://www.runoob.com/scala/scala-collections.html">更多api</a></p>
<ol>
<li>List</li>
</ol>
<pre><code class="language-java">//定义
val list:List[String] = List(&quot;hello&quot;,&quot;world&quot;)
// 空列表
val empty: List[Nothing] = List()
// 二维列表
val dim: List[List[Int]] =
  List(
    List(1, 0, 0),
    List(0, 1, 0),
    List(0, 0, 1)
  )
//构造列表的两个基本单位是 Nil 和 ::
//Nil 也可以表示为一个空列表。
//以上实例我们可以写成如下所示：
// 整型列表
val nums = 1 :: (2 :: (3 :: (4 :: Nil)))
// 空列表
val empty2 = Nil
// 二维列表
val dim2 = (1 :: (0 :: (0 :: Nil))) ::
  (0 :: (1 :: (0 :: Nil))) ::
  (0 :: (0 :: (1 :: Nil))) :: Nil
print(nums)

//常用方法
val list:List[String] = List(&quot;hello&quot;,&quot;world&quot;,&quot;!!!&quot;)
//获取第一个元素
println(list.head)
//获取最后一个元素
println(list.tail)
//判空
println(list.isEmpty)
//列表链接 ::: 或 concat
val list2 = List(&quot;gu&quot;,&quot;ge&quot;)
println(list:::list2)
println(List.concat(list2,list))
//指定元素重复列表
println(List.fill(3)(&quot;HI!&quot;))
//List.tabulate() 方法是通过给定的函数来创建列表
//就是循环到n,每次循环得到的元素调用第二个形参的函数,将返回值存入list
println(List.tabulate(9)(n=&gt;2*n))
</code></pre>
<ol start="2">
<li>Set</li>
</ol>
<pre><code class="language-java">//定义
val set = Set(1,2,3)
//获取第一个元素
println(set.head)
//tail 返回一个集合，包含除了第一元素之外的其他元素
println(set.tail)
//拼接
val set2 = Set(4,5,6)
println(set ++ set2)
//交集
val set3 = Set(5,6,7)
println(set2.intersect(set3))
</code></pre>
<ol start="3">
<li>Map</li>
</ol>
<pre><code class="language-java">//定义
val map : Map[String,Int] = Map()
//or
var map2 = Map(&quot;k1&quot; -&gt; 1, &quot;k2&quot; -&gt; 2)
//add
map2 += (&quot;k3&quot;-&gt;3)
//keys
println(map2.keys)
//values
println(map2.values)
//合并
var map3 = Map(&quot;k4&quot; -&gt; 4, &quot;k5&quot; -&gt; 5)
println(map2 ++ map3)
</code></pre>
<ol start="4">
<li>Tuple元祖</li>
</ol>
<pre><code class="language-java">//元祖是不同类型值的集合
val t = (1, 3.14, &quot;Fred&quot;)
//或
val t2 = Tuple3(5, 5.14, &quot;Fred2&quot;)
//访问
println(t)
println(t._1)
println(t._2)
</code></pre>
<ol start="5">
<li>option</li>
</ol>
<pre><code class="language-java">//map访问key返回的是Option对象
//有值时Some 没有时None
//调用get获取具体值
val myMap: Map[String, String] = Map(&quot;key1&quot; -&gt; &quot;value&quot;)
val value1: Option[String] = myMap.get(&quot;key1&quot;)
val value2: Option[String] = myMap.get(&quot;key2&quot;)

println(value1) // Some(&quot;value&quot;)
println(value2) // None
println(value1.get) // value
//println(value2.get) //exception
//getOrElse代表为空时返回的值
println(value1.getOrElse(1)) //value
println(value2.getOrElse(1)) //1
</code></pre>
<h3 id="迭代器-iterator">迭代器 Iterator</h3>
<p>和Java的差不多,不是集合,是用于访问几个的方法</p>
<pre><code class="language-java">val it = Iterator(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;)

while (it.hasNext){
  println(it.next())
}
</code></pre>
<p><a href="https://www.runoob.com/scala/scala-iterators.html">其他api</a></p>
<h3 id="类和对象">类和对象</h3>
<ol>
<li>类的定义</li>
</ol>
<pre><code class="language-java">def main(args: Array[String]): Unit = {
  val point : Point= new Point(1,2)
  point.move(1,2)
}
//Scala中的类不声明为public，一个Scala源文件中可以有多个类
class Point(xc: Int, yc: Int) {
  var x: Int = xc
  var y: Int = yc

  def move(dx: Int, dy: Int) {
    x = x + dx
    y = y + dy
    println (&quot;x 的坐标点: &quot; + x);
    println (&quot;y 的坐标点: &quot; + y);
  }
  def name(): Unit ={
      println(&quot;point&quot;)
  }    
}
</code></pre>
<ol start="2">
<li>继承</li>
</ol>
<pre><code class="language-java">//1、重写一个非抽象方法必须使用override修饰符。
//2、只有主构造函数才可以往基类的构造函数里写参数。
//3、在子类中重写超类的抽象方法时，你不需要使用override关键字。
// 重载超类方法也不需要override关键字。
//子类的构造参数必须包含父类的
class Location( val xc: Int, val yc: Int, val zc :Int) 
                                    extends Point(xc, yc){
  var z: Int = zc

  def move(dx: Int, dy: Int, dz: Int) {
    x = x + dx
    y = y + dy
    z = z + dz
    println (&quot;x 的坐标点 : &quot; + x);
    println (&quot;y 的坐标点 : &quot; + y);
    println (&quot;z 的坐标点 : &quot; + z);
  }

  override def name(): Unit = {
    super.name()
    println(&quot;location&quot;)
  }
}
</code></pre>
<ol start="3">
<li>单例对象</li>
</ol>
<pre><code class="language-java">//scala没有static关键字
//需要有一个常量类里定义一些静态变量和方法,要用到object关键字 
//(main方法也在这里运行)
object ConstantUtil{
  val TYPE_ONE = &quot;1&quot;
  val TYPE_TWO = &quot;2&quot;
  val SEX_MAN = 1
  def LOG(msg: String ): Unit = {
    println(msg)
  }

  def main(args: Array[String]): Unit = {
    println(ConstantUtil.SEX_MAN)
    println(ConstantUtil.TYPE_ONE)
    ConstantUtil.LOG(&quot;sss&quot;)

  }
}


//Scala使用单例模式需要定义一个同名的class和object
//该object定义的对象称为class的伴生对象,可以访问其私有方法
class Conf private(val num:Int) {

  def print(): Unit ={
    println(num)
  }

}
object Conf {
  var conf1 = new Conf(1)
  var conf2 = new Conf(2)

  def main(args: Array[String]): Unit = {
    Conf.conf1.print()
  }
}
</code></pre>
<ol start="11">
<li>rait(特征)</li>
</ol>
<pre><code class="language-java">//Scala的特征相当于Java接口
//但是可以定义属性和方法的实现,这里更像是抽象类
//可以多个继承特征
trait Graph{

  var length : Double

  var width : Double

  def girth() : Double
}

class rect (len: Double,wid : Double) extends Graph{
  override var length: Double = len
  override var width: Double = wid

  override def girth(): Double = {
    length*width
  }
}
object Test{
  def main(args: Array[String]): Unit = {
    val rect = new rect(1,2)
    println(rect.girth())
  }
}
</code></pre>
<blockquote>
<p>特征也可以有构造器，由字段的初始化和其他特征体中的语句构成。这些语句在任何混入该特征的对象在构造时都会被执行。</p>
<blockquote>
<p>构造器的执行顺序：</p>
<ol>
<li>调用超类的构造器；</li>
<li>特征构造器在超类构造器之后、类构造器之前执行；</li>
<li>特征由左到右被构造；</li>
<li>每个特征当中，父特征先被构造；</li>
<li>如果多个特征共有一个父特征，父特征不会被重复构造</li>
<li>所有特征被构造完毕，子类被构造。</li>
<li>构造器的顺序是类的线性化的反向。线性化是描述某个类型的所有超类型的一种技术规格。</li>
</ol>
</blockquote>
</blockquote>
<h3 id="模式匹配">模式匹配</h3>
<pre><code class="language-java">//相当于Java的Seitch-case ,默认匹配1个直接返回, _相当于default,可以自动检查类型匹配
object Test2 {
  def main(args: Array[String]) {
    println(matchTest(&quot;two&quot;))
    println(matchTest(&quot;test&quot;))
    println(matchTest(1))
    println(matchTest(6))

  }
  def matchTest(x: Any): Any = x match {
    case 1 =&gt; &quot;one&quot;
    case &quot;two&quot; =&gt; 2
    case y: Int =&gt; &quot;scala.Int&quot;
    case _ =&gt; &quot;many&quot;
  }
}

//样例类 用于特殊的模式匹配
object Test {
   def main(args: Array[String]) {
       val alice = new Person(&quot;Alice&quot;, 25)
    val bob = new Person(&quot;Bob&quot;, 32)
       val charlie = new Person(&quot;Charlie&quot;, 32)
   
    for (person &lt;- List(alice, bob, charlie)) {
        person match {
            case Person(&quot;Alice&quot;, 25) =&gt; println(&quot;Hi Alice!&quot;)
            case Person(&quot;Bob&quot;, 32) =&gt; println(&quot;Hi Bob!&quot;)
            case Person(name, age) =&gt;
               println(&quot;Age: &quot; + age + &quot; year, name: &quot; + name + &quot;?&quot;)
         }
      }
   }
   // 样例类
   case class Person(name: String, age: Int)
}
</code></pre>
<h3 id="scala的正则">Scala的正则</h3>
<p><a href="https://www.runoob.com/scala/scala-regular-expressions.html">详细</a></p>
<h3 id="异常">异常</h3>
<pre><code class="language-java">//大部分和Java一样,捕获不同类型异常有点不一样
object Test4 {
  def main(args: Array[String]) {
    try {
      val f = new FileReader(&quot;input.txt&quot;)
    } catch {
      case ex: FileNotFoundException =&gt;{
        println(&quot;Missing file exception&quot;)
      }
      case ex: IOException =&gt; {
        println(&quot;IO Exception&quot;)
      }
    } finally{

    }
  }
}
</code></pre>
<h3 id="文件io">文件I/O</h3>
<pre><code class="language-java">//用的全是JAVA的API
object Test6 {
  def main(args: Array[String]) {
    val writer = new PrintWriter(new File(&quot;D://test.txt&quot; ))

    writer.write(&quot;1&quot;)
    writer.close()
  }
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B">变量类型</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">访问修饰符</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF">循环</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E4%B8%8E%E5%87%BD%E6%95%B0">方法与函数</a></li>
<li><a href="#%E9%97%AD%E5%8C%85">闭包</a></li>
<li><a href="#%E6%95%B0%E7%BB%84">数组</a></li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator">迭代器 Iterator</a></li>
<li><a href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">类和对象</a></li>
<li><a href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a></li>
<li><a href="#scala%E7%9A%84%E6%AD%A3%E5%88%99">Scala的正则</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li>
<li><a href="#%E6%96%87%E4%BB%B6io">文件I/O</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
<meta name="google-site-verification" content="OHXgtWBObgyvWN7WXe8Ae7sxpSyjq-j9R0ZY-MlKYgw" /> | 
  <a class="rss" href="https://tobin4j.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
