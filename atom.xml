<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tobin4j.github.io</id>
    <title>libg的个人博客</title>
    <updated>2019-12-28T14:17:13.757Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tobin4j.github.io"/>
    <link rel="self" href="https://tobin4j.github.io/atom.xml"/>
    <subtitle>热爱可抵岁月漫长。</subtitle>
    <logo>https://tobin4j.github.io/images/avatar.png</logo>
    <icon>https://tobin4j.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, libg的个人博客</rights>
    <entry>
        <title type="html"><![CDATA[Scala学习笔记]]></title>
        <id>https://tobin4j.github.io/post/scala-xue-xi-bi-ji</id>
        <link href="https://tobin4j.github.io/post/scala-xue-xi-bi-ji">
        </link>
        <updated>2019-12-28T12:58:32.000Z</updated>
        <summary type="html"><![CDATA[<p>主要记录学习Scala基础语法，因为我主语言是Java，笔记主要比较了和Java的异同。</p>
]]></summary>
        <content type="html"><![CDATA[<p>主要记录学习Scala基础语法，因为我主语言是Java，笔记主要比较了和Java的异同。</p>
<!-- more -->
<blockquote>
<p>语言特点:编译后同样是.class文件允许在Jvm的语言，和Java包无缝互调</p>
</blockquote>
<h3 id="变量类型">变量类型</h3>
<ol>
<li>普通变量</li>
</ol>
<pre><code class="language-java">var myVar : String = &quot;Foo&quot;
</code></pre>
<p>代表声明了一个变量叫 myVar ，类型是 String , 值是 “foo”<br>
如果不声明冒号后面的String，则会默认推断值的类型<br>
2. 常量</p>
<pre><code class="language-java">val myVar : String = &quot;Foo&quot;
</code></pre>
<p>不同的是改声明的变量后续不能被再次赋值<br>
3. 多个变量声明</p>
<pre><code class="language-java">var a,b = 1 //两个变量都声明为1
</code></pre>
<ol start="4">
<li>方法返回值是元祖</li>
</ol>
<pre><code class="language-java">var tmp = (1,2)
</code></pre>
<blockquote>
<p>可以直接接受然后推测类型</p>
</blockquote>
<h3 id="访问修饰符">访问修饰符</h3>
<p>不声明默认是public，priate和protected比Java更严格</p>
<pre><code class="language-java">//作用域保护
private[x] 
//x是包名,代表其声明的类或对象对x包中的类开放
protected[x]
</code></pre>
<h3 id="运算符">运算符</h3>
<p>scala没有++,--运算符</p>
<h3 id="循环">循环</h3>
<ul>
<li>while 和 do...while和Java一样</li>
<li>没有break和continue(有包可以解决)</li>
</ul>
<pre><code class="language-java">for (a &lt;- 1 to 10){
    //遍历1到10（包含）
}

for (a &lt;- 1 until 10){
    //遍历1到10（不包含）
}

for (a &lt;- 1 to 10;b &lt;- 1 to 15 ){
    //遍历a和b所有存在的组合(相当去嵌套循环)
}

for (a &lt;- list){
    //遍历集合对象
}

for (a &lt;- 1 to 10
    if a%2==0){
    //for循环机中过滤
}

var sl= for (a &lt;- 1 until 10){
    //将遍历结果a汇总后赋值给sl
      }yield a
</code></pre>
<h3 id="方法与函数">方法与函数</h3>
<ol>
<li>方法定义</li>
</ol>
<pre><code class="language-java">//定义一个方法叫add,接受两个Int类型的参数,返回值是Int
//只有一行大括号和return可以省略
//返回值可以是Unit 相当Java的void
//可以指定默认值
//可以嵌套
def add(x:Int=5,y:Int) : Int = {
    return x+y
}
</code></pre>
<ol start="2">
<li>函数定义</li>
</ol>
<pre><code class="language-java">val add = (x:Int,y:Int) =&gt; x+y
//可以根据参数名指定调用顺序
print(add(y=1,x=2))
//定义可变长参数
def add(args:Int*) ={
    
}
</code></pre>
<ol start="3">
<li>其他</li>
</ol>
<p>https://www.runoob.com/scala/scala-functions.html</p>
<h3 id="闭包">闭包</h3>
<p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</p>
<pre><code class="language-java">var a = 2
var fun = (b:Int) =&gt; a+b
</code></pre>
<h3 id="数组">数组</h3>
<ol>
<li>数组定义</li>
</ol>
<pre><code class="language-java">var arr1 : Array[String] = new Array[String](3)
//下标索引
arr1(0)=&quot;str0&quot;
arr1(1)=&quot;str1&quot;
arr1(2)=&quot;str2&quot;
//或
val arr2 = Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)
//遍历
for (str &lt;- arr2){
  println(str)
}
</code></pre>
<ol start="2">
<li>二维数组</li>
</ol>
<pre><code class="language-java">//定义,赋值,遍历
import Array._
var mat = ofDim[Int](3,3)
for (a &lt;- 0 to 2;b&lt;- 0 until 3){
  mat(a)(b)=666
}
for (a &lt;- 0 to 2){
  for (b&lt;- 0 until 3){
    print(mat(a)(b))
    print(&quot; &quot;)
  }
  println()
}
</code></pre>
<ol start="3">
<li>合并数组</li>
</ol>
<pre><code class="language-java">var myList1 = Array(1.9, 2.9, 3.4, 3.5)
var myList2 = Array(8.9, 7.9, 0.4, 1.5)

var myList3 =  concat( myList1, myList2)

// 输出所有数组元素
for ( x &lt;- myList3 ) {
  println( x )
}
</code></pre>
<ol start="4">
<li>创建区间数组</li>
</ol>
<pre><code class="language-java">//range函数最后一个形参是步长,默认1
var myList1 = range(10, 20, 2)
var myList2 = range(10,20)

// 输出所有数组元素
for ( x &lt;- myList1 ) {
    print( &quot; &quot; + x )
}
println()
for ( x &lt;- myList2 ) {
    print( &quot; &quot; + x )
}
</code></pre>
<ol start="5">
<li><a href="https://www.runoob.com/scala/scala-arrays.html">常用方法</a></li>
</ol>
<h3 id="集合">集合</h3>
<p><a href="https://www.runoob.com/scala/scala-collections.html">更多api</a></p>
<ol>
<li>List</li>
</ol>
<pre><code class="language-java">//定义
val list:List[String] = List(&quot;hello&quot;,&quot;world&quot;)
// 空列表
val empty: List[Nothing] = List()
// 二维列表
val dim: List[List[Int]] =
  List(
    List(1, 0, 0),
    List(0, 1, 0),
    List(0, 0, 1)
  )
//构造列表的两个基本单位是 Nil 和 ::
//Nil 也可以表示为一个空列表。
//以上实例我们可以写成如下所示：
// 整型列表
val nums = 1 :: (2 :: (3 :: (4 :: Nil)))
// 空列表
val empty2 = Nil
// 二维列表
val dim2 = (1 :: (0 :: (0 :: Nil))) ::
  (0 :: (1 :: (0 :: Nil))) ::
  (0 :: (0 :: (1 :: Nil))) :: Nil
print(nums)

//常用方法
val list:List[String] = List(&quot;hello&quot;,&quot;world&quot;,&quot;!!!&quot;)
//获取第一个元素
println(list.head)
//获取最后一个元素
println(list.tail)
//判空
println(list.isEmpty)
//列表链接 ::: 或 concat
val list2 = List(&quot;gu&quot;,&quot;ge&quot;)
println(list:::list2)
println(List.concat(list2,list))
//指定元素重复列表
println(List.fill(3)(&quot;HI!&quot;))
//List.tabulate() 方法是通过给定的函数来创建列表
//就是循环到n,每次循环得到的元素调用第二个形参的函数,将返回值存入list
println(List.tabulate(9)(n=&gt;2*n))
</code></pre>
<ol start="2">
<li>Set</li>
</ol>
<pre><code class="language-java">//定义
val set = Set(1,2,3)
//获取第一个元素
println(set.head)
//tail 返回一个集合，包含除了第一元素之外的其他元素
println(set.tail)
//拼接
val set2 = Set(4,5,6)
println(set ++ set2)
//交集
val set3 = Set(5,6,7)
println(set2.intersect(set3))
</code></pre>
<ol start="3">
<li>Map</li>
</ol>
<pre><code class="language-java">//定义
val map : Map[String,Int] = Map()
//or
var map2 = Map(&quot;k1&quot; -&gt; 1, &quot;k2&quot; -&gt; 2)
//add
map2 += (&quot;k3&quot;-&gt;3)
//keys
println(map2.keys)
//values
println(map2.values)
//合并
var map3 = Map(&quot;k4&quot; -&gt; 4, &quot;k5&quot; -&gt; 5)
println(map2 ++ map3)
</code></pre>
<ol start="4">
<li>Tuple元祖</li>
</ol>
<pre><code class="language-java">//元祖是不同类型值的集合
val t = (1, 3.14, &quot;Fred&quot;)
//或
val t2 = Tuple3(5, 5.14, &quot;Fred2&quot;)
//访问
println(t)
println(t._1)
println(t._2)
</code></pre>
<ol start="5">
<li>option</li>
</ol>
<pre><code class="language-java">//map访问key返回的是Option对象
//有值时Some 没有时None
//调用get获取具体值
val myMap: Map[String, String] = Map(&quot;key1&quot; -&gt; &quot;value&quot;)
val value1: Option[String] = myMap.get(&quot;key1&quot;)
val value2: Option[String] = myMap.get(&quot;key2&quot;)

println(value1) // Some(&quot;value&quot;)
println(value2) // None
println(value1.get) // value
//println(value2.get) //exception
//getOrElse代表为空时返回的值
println(value1.getOrElse(1)) //value
println(value2.getOrElse(1)) //1
</code></pre>
<h3 id="迭代器-iterator">迭代器 Iterator</h3>
<p>和Java的差不多,不是集合,是用于访问几个的方法</p>
<pre><code class="language-java">val it = Iterator(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;)

while (it.hasNext){
  println(it.next())
}
</code></pre>
<p><a href="https://www.runoob.com/scala/scala-iterators.html">其他api</a></p>
<h3 id="类和对象">类和对象</h3>
<ol>
<li>类的定义</li>
</ol>
<pre><code class="language-java">def main(args: Array[String]): Unit = {
  val point : Point= new Point(1,2)
  point.move(1,2)
}
//Scala中的类不声明为public，一个Scala源文件中可以有多个类
class Point(xc: Int, yc: Int) {
  var x: Int = xc
  var y: Int = yc

  def move(dx: Int, dy: Int) {
    x = x + dx
    y = y + dy
    println (&quot;x 的坐标点: &quot; + x);
    println (&quot;y 的坐标点: &quot; + y);
  }
  def name(): Unit ={
      println(&quot;point&quot;)
  }    
}
</code></pre>
<ol start="2">
<li>继承</li>
</ol>
<pre><code class="language-java">//1、重写一个非抽象方法必须使用override修饰符。
//2、只有主构造函数才可以往基类的构造函数里写参数。
//3、在子类中重写超类的抽象方法时，你不需要使用override关键字。
// 重载超类方法也不需要override关键字。
//子类的构造参数必须包含父类的
class Location( val xc: Int, val yc: Int, val zc :Int) 
                                    extends Point(xc, yc){
  var z: Int = zc

  def move(dx: Int, dy: Int, dz: Int) {
    x = x + dx
    y = y + dy
    z = z + dz
    println (&quot;x 的坐标点 : &quot; + x);
    println (&quot;y 的坐标点 : &quot; + y);
    println (&quot;z 的坐标点 : &quot; + z);
  }

  override def name(): Unit = {
    super.name()
    println(&quot;location&quot;)
  }
}
</code></pre>
<ol start="3">
<li>单例对象</li>
</ol>
<pre><code class="language-java">//scala没有static关键字
//需要有一个常量类里定义一些静态变量和方法,要用到object关键字 
//(main方法也在这里运行)
object ConstantUtil{
  val TYPE_ONE = &quot;1&quot;
  val TYPE_TWO = &quot;2&quot;
  val SEX_MAN = 1
  def LOG(msg: String ): Unit = {
    println(msg)
  }

  def main(args: Array[String]): Unit = {
    println(ConstantUtil.SEX_MAN)
    println(ConstantUtil.TYPE_ONE)
    ConstantUtil.LOG(&quot;sss&quot;)

  }
}


//Scala使用单例模式需要定义一个同名的class和object
//该object定义的对象称为class的伴生对象,可以访问其私有方法
class Conf private(val num:Int) {

  def print(): Unit ={
    println(num)
  }

}
object Conf {
  var conf1 = new Conf(1)
  var conf2 = new Conf(2)

  def main(args: Array[String]): Unit = {
    Conf.conf1.print()
  }
}
</code></pre>
<ol start="11">
<li>rait(特征)</li>
</ol>
<pre><code class="language-java">//Scala的特征相当于Java接口
//但是可以定义属性和方法的实现,这里更像是抽象类
//可以多个继承特征
trait Graph{

  var length : Double

  var width : Double

  def girth() : Double
}

class rect (len: Double,wid : Double) extends Graph{
  override var length: Double = len
  override var width: Double = wid

  override def girth(): Double = {
    length*width
  }
}
object Test{
  def main(args: Array[String]): Unit = {
    val rect = new rect(1,2)
    println(rect.girth())
  }
}
</code></pre>
<blockquote>
<p>特征也可以有构造器，由字段的初始化和其他特征体中的语句构成。这些语句在任何混入该特征的对象在构造时都会被执行。</p>
<blockquote>
<p>构造器的执行顺序：</p>
<ol>
<li>调用超类的构造器；</li>
<li>特征构造器在超类构造器之后、类构造器之前执行；</li>
<li>特征由左到右被构造；</li>
<li>每个特征当中，父特征先被构造；</li>
<li>如果多个特征共有一个父特征，父特征不会被重复构造</li>
<li>所有特征被构造完毕，子类被构造。</li>
<li>构造器的顺序是类的线性化的反向。线性化是描述某个类型的所有超类型的一种技术规格。</li>
</ol>
</blockquote>
</blockquote>
<h3 id="模式匹配">模式匹配</h3>
<pre><code class="language-java">//相当于Java的Seitch-case ,默认匹配1个直接返回, _相当于default,可以自动检查类型匹配
object Test2 {
  def main(args: Array[String]) {
    println(matchTest(&quot;two&quot;))
    println(matchTest(&quot;test&quot;))
    println(matchTest(1))
    println(matchTest(6))

  }
  def matchTest(x: Any): Any = x match {
    case 1 =&gt; &quot;one&quot;
    case &quot;two&quot; =&gt; 2
    case y: Int =&gt; &quot;scala.Int&quot;
    case _ =&gt; &quot;many&quot;
  }
}

//样例类 用于特殊的模式匹配
object Test {
   def main(args: Array[String]) {
       val alice = new Person(&quot;Alice&quot;, 25)
    val bob = new Person(&quot;Bob&quot;, 32)
       val charlie = new Person(&quot;Charlie&quot;, 32)
   
    for (person &lt;- List(alice, bob, charlie)) {
        person match {
            case Person(&quot;Alice&quot;, 25) =&gt; println(&quot;Hi Alice!&quot;)
            case Person(&quot;Bob&quot;, 32) =&gt; println(&quot;Hi Bob!&quot;)
            case Person(name, age) =&gt;
               println(&quot;Age: &quot; + age + &quot; year, name: &quot; + name + &quot;?&quot;)
         }
      }
   }
   // 样例类
   case class Person(name: String, age: Int)
}
</code></pre>
<h3 id="scala的正则">Scala的正则</h3>
<p><a href="https://www.runoob.com/scala/scala-regular-expressions.html">详细</a></p>
<h3 id="异常">异常</h3>
<pre><code class="language-java">//大部分和Java一样,捕获不同类型异常有点不一样
object Test4 {
  def main(args: Array[String]) {
    try {
      val f = new FileReader(&quot;input.txt&quot;)
    } catch {
      case ex: FileNotFoundException =&gt;{
        println(&quot;Missing file exception&quot;)
      }
      case ex: IOException =&gt; {
        println(&quot;IO Exception&quot;)
      }
    } finally{

    }
  }
}
</code></pre>
<h3 id="文件io">文件I/O</h3>
<pre><code class="language-java">//用的全是JAVA的API
object Test6 {
  def main(args: Array[String]) {
    val writer = new PrintWriter(new File(&quot;D://test.txt&quot; ))

    writer.write(&quot;1&quot;)
    writer.close()
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[就从我高中毕业说起(1)]]></title>
        <id>https://tobin4j.github.io/post/cong-wo-gao-zhong-bi-ye-shuo-qi-1</id>
        <link href="https://tobin4j.github.io/post/cong-wo-gao-zhong-bi-ye-shuo-qi-1">
        </link>
        <updated>2019-12-28T08:35:26.000Z</updated>
        <summary type="html"><![CDATA[<p>2013年的夏天，随着考试结束铃声的响起，我毕业了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>2013年的夏天，随着考试结束铃声的响起，我毕业了。</p>
<!-- more -->
<hr>
<p>夏日的县城，空气弥漫着焦灼的气息。最后一场考试结束，对于每个考生自身意味着什么，这在当时是没有清晰认知的，于我而言，亦或是多数人，唯有<strong>自由</strong>两个字。</p>
<blockquote>
<p>高中毕业后你们就自由了。</p>
</blockquote>
<p>搞笑的是，在大学毕业后，我竟还是觉得这话没啥毛病，因为我大学过的也确实很自由（这就是后话了）。</p>
<p>其实我当时考的并不好，或者是，我压根就没考好过？但是在当时甚至很长一段时间，我都没有认识到这意味着什么。</p>
<p>回到教室收拾好书本，同学脸上大都洋溢着微笑，这场12年的长跑，以及最后1年的冲刺终于落下帷幕，没有人担心自己考的不好，亦或是复读什么事情，因为都知道自己是什么B样。</p>
<p>回宿舍的时候，我接到了一个电话，是我的同桌，也是我的暗恋对象<strong>小美</strong>（化名）打来的。</p>
<blockquote>
<p>“你充电宝还在我这。”</p>
</blockquote>
<p>但当时男生的心里装的是电脑里的<strong>江湖</strong>，<strong>剑</strong>，<strong>天涯</strong>和<strong>明月</strong>，哪还容的下一个充电宝。</p>
<blockquote>
<p>“送你了，我不要了。”</p>
</blockquote>
<p>那时已认为和她基本上也不可能了，毕业于之后都要各奔东西，这也是我高三喜欢上他迟迟没有表白的原因。（总结就一个字，怂）</p>
<blockquote>
<p>“定情信物。”</p>
</blockquote>
<p>她俏皮的说完这四个字就挂了。</p>
<p>夏风不往前吹了，带着几片落叶盘旋在我脚边，知了也叫累了，整个世界就像被静音，唯有这四个字始终回响在我脑海。</p>
<blockquote>
<p>青春期的女生仿佛永远也不会明白她随口说的话可以对同龄男生产生多大影响。</p>
</blockquote>
<p>“同学，哪里不舒服吗？要不去医务室看看？”</p>
<p>我立马回过神来，面色尴尬的对问话的老师说没事，然后小跑回宿舍。</p>
<p>收拾完东西后就是坐等父亲来接了。</p>
<p>看着被搬空的宿舍，想起在这里生活的一个个片段，那些嬉笑谩骂，深夜畅谈，那些吹过的牛逼，做过的糗事。宿舍的书桌似乎还能看见那半夜伏着补作业的人。我明白，这次一别，对很多人来说，可能就是一辈子了。</p>
<blockquote>
<p>我再也不属于这里了，我曾经最不喜的地方。</p>
</blockquote>
<hr>
<p>k</p>
<hr>
<h1 id="写在最后的说明">写在最后的说明</h1>
<p>一直想写点什么，却又不知道写什么，思来想去准备记录下高中毕业到目前横跨6年的时光，我所经历的吧。<br>
很多事情记忆已经模糊，但总有些人和事，记忆犹新。</p>
]]></content>
    </entry>
</feed>